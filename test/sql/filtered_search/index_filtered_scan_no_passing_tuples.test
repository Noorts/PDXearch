# name: test/sql/filtered_search/index_filtered_scan_no_passing_tuples.test
# description: Ensure no crash occurs during a filtered search if an entire row group's tuples are filtered out and the iteration mechanism is used.
# group: [filtered_search]

require parquet

require pdxearch

# Variables
test-env ROW_GROUP_SIZE 122880

test-env DIMS 128

test-env N_PROBE 1

test-env QUERY_EMB [0,16,35,5,32,31,14,10,11,78,55,10,45,83,11,6,14,57,102,75,20,8,3,5,67,17,19,26,5,0,1,22,60,26,7,1,18,22,84,53,85,119,119,4,24,18,7,7,1,81,106,102,72,30,6,0,9,1,9,119,72,1,4,33,119,29,6,1,0,1,14,52,119,30,3,0,0,55,92,111,2,5,4,9,22,89,96,14,1,0,1,82,59,16,20,5,25,14,11,4,0,0,1,26,47,23,4,0,0,4,38,83,30,14,9,4,9,17,23,41,0,0,2,8,19,25,23,1]

test-env LIMIT 50

# Set up the table and rows.
statement ok
CREATE TABLE t1 (id INTEGER, emb FLOAT[${DIMS}]);

# Insert two row groups.
statement ok
INSERT INTO t1 FROM read_parquet('test/assets/sift-128-euclidean-245760.parquet') LIMIT ${ROW_GROUP_SIZE} * 2;

query I
SELECT COUNT(*) FROM t1;
----
245760

query I
SELECT COUNT(*) FROM t1 WHERE id > (${ROW_GROUP_SIZE} + ${ROW_GROUP_SIZE} - 10);
----
9

foreach metric_name,distance_func l2sq,array_distance cosine,array_cosine_distance ip,array_negative_inner_product

statement ok
DROP INDEX IF EXISTS t1_idx;

statement ok
CREATE INDEX t1_idx ON t1 USING PDXEARCH (emb) WITH (metric = '${metric_name}', n_probe = ${N_PROBE});

# Trigger the iteration mechanism by ensuring < K (9 in this case) tuples enter the heap in the first iteration.
# The search will conclude once all partitions have been probed (this is done in multiple iterations).
statement ok
SELECT * FROM t1 WHERE id > (${ROW_GROUP_SIZE} + ${ROW_GROUP_SIZE} - 10)
    ORDER BY ${distance_func}(emb, ${QUERY_EMB}::FLOAT[${DIMS}]) LIMIT ${LIMIT};

endloop
