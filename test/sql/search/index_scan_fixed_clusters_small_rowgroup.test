# name: test/sql/search/index_scan_fixed_clusters_small_rowgroup.test
# description: Ensure we create exactly 120 clusters. See `ComputeNumClustersForRowGroup`.
# group: [search]

require parquet

require pdxearch

# Variables
test-env INDEX_SEED 0

test-env DIMS 128

# A rowgroup of less rows than 30720 triggers only 120 clusters
test-env NUM_ROWS 30719

test-env QUERY_EMB [0,16,35,5,32,31,14,10,11,78,55,10,45,83,11,6,14,57,102,75,20,8,3,5,67,17,19,26,5,0,1,22,60,26,7,1,18,22,84,53,85,119,119,4,24,18,7,7,1,81,106,102,72,30,6,0,9,1,9,119,72,1,4,33,119,29,6,1,0,1,14,52,119,30,3,0,0,55,92,111,2,5,4,9,22,89,96,14,1,0,1,82,59,16,20,5,25,14,11,4,0,0,1,26,47,23,4,0,0,4,38,83,30,14,9,4,9,17,23,41,0,0,2,8,19,25,23,1]

test-env LIMIT 50

# Set up the table and rows.
statement ok
CREATE OR REPLACE TABLE t1 (id INTEGER, emb FLOAT[${DIMS}]);

statement ok
INSERT INTO t1 FROM read_parquet('test/assets/sift-128-euclidean-245760.parquet') LIMIT ${NUM_ROWS};

foreach quantization f32

foreach metric_name,distance_func l2sq,array_distance cosine,array_cosine_distance ip,array_negative_inner_product

statement ok
CREATE OR REPLACE TABLE t_gt AS SELECT * FROM t1 ORDER BY ${distance_func}(emb, ${QUERY_EMB}::FLOAT[${DIMS}]) LIMIT ${LIMIT};

statement ok
DROP INDEX IF EXISTS t1_idx;

statement ok
CREATE INDEX t1_idx ON t1 USING PDXEARCH (emb) WITH (metric = '${metric_name}', quantization = '${quantization}', seed = ${INDEX_SEED});

statement ok
CREATE OR REPLACE TABLE results (dist_func VARCHAR, quant VARCHAR, n_probe INTEGER, recall FLOAT);

foreach n_probe 1 120 480

statement ok
SET pdxearch_n_probe = ${n_probe};

query II
EXPLAIN SELECT * FROM t1 ORDER BY ${distance_func}(emb, ${QUERY_EMB}::FLOAT[${DIMS}]) LIMIT ${LIMIT};
----
physical_plan	<REGEX>:.*PDXEARCH_INDEX_SCAN.*

statement ok
CREATE OR REPLACE TABLE t_idx_res AS SELECT * FROM t1 ORDER BY ${distance_func}(emb, ${QUERY_EMB}::FLOAT[${DIMS}]) LIMIT ${LIMIT};

# Verify that the index scan returns the correct number of rows
query I
SELECT COUNT(*) > 0 AND COUNT(*) <= ${LIMIT} FROM t_idx_res;
----
true

# Compute recall for this n_probe.
statement ok
INSERT INTO results (dist_func, quant, n_probe, recall) VALUES ('${distance_func}', '${quantization}', ${n_probe},
    (SELECT COUNT(*) FROM t_gt JOIN t_idx_res USING (id)) / ${LIMIT});

endloop

# Ensure recall is the same at 480 and 120, ensuring that we have created only 120 clusters
query I
SELECT diff == 0 FROM (
  SELECT recall - lag(recall) OVER () as diff FROM results WHERE n_probe IN (120, 480)
) WHERE diff IS NOT NULL;
----
true

# Ensure recall is lower with n_probe = 1, meaning that we don't have just 1 cluster
query I
SELECT recall < 0.95 FROM results WHERE n_probe = 1;
----
true

endloop

endloop
