#pragma once

#include <cstdint>
#include <cmath>
#include <algorithm>
#include <limits>
#include "pdxearch/common.hpp"

namespace PDX {

struct ScalarQuantizationParams {
	float quantization_base;
	float quantization_scale;
};

class Quantizer {

public:
	explicit Quantizer(size_t num_dimensions) : num_dimensions(num_dimensions) {
	}
	virtual ~Quantizer() = default;

public:
	void NormalizeQuery(const float *src, float *out) const {
		float sum = 0.0f;
		for (size_t i = 0; i < num_dimensions; ++i) {
			sum += src[i] * src[i];
		}

		if (sum == 0.0f) {
			return;
		}

		float norm = std::sqrt(sum);
		for (size_t i = 0; i < num_dimensions; ++i) {
			out[i] = src[i] / norm;
		}
	}
	const size_t num_dimensions;
};

template <Quantization q = U8>
class ScalarQuantizer : public Quantizer {
public:
	using quantized_vector_t = QuantizedVectorType_t<q>;

	explicit ScalarQuantizer(size_t num_dimensions) : Quantizer(num_dimensions) {
	}

#ifdef __AVX512F__
	// We rely on _mm512_dpbusds_epi32 that has asymmetric operands
	static constexpr uint8_t MAX_VALUE = 127;
#else
	static constexpr uint8_t MAX_VALUE = 255;
#endif

	static ScalarQuantizationParams ComputeQuantizationParams(const float *embeddings, size_t total_elements) {
		float global_min = std::numeric_limits<float>::max();
		float global_max = std::numeric_limits<float>::lowest();
		for (size_t i = 0; i < total_elements; ++i) {
			global_min = std::min(global_min, embeddings[i]);
			global_max = std::max(global_max, embeddings[i]);
		}
		float range = global_max - global_min;
		return {global_min, (range > 0) ? static_cast<float>(MAX_VALUE) / range : 1.0f};
	}

	void QuantizeVector(const float *input, const float quantization_base, const float quantization_scale,
	                    quantized_vector_t *output) {
		for (size_t i = 0; i < num_dimensions; ++i) {
			int rounded = static_cast<int>(std::round((input[i] - quantization_base) * quantization_scale));
			if (PDX_UNLIKELY(rounded > MAX_VALUE)) {
				output[i] = MAX_VALUE;
			} else if (PDX_UNLIKELY(rounded < 0)) {
				output[i] = 0;
			} else {
				output[i] = static_cast<uint8_t>(rounded);
			}
		}
	}
};

} // namespace PDX
